[["kata-pengantar.html", "WORKSHOP Data Analytics With Python &amp; SQL Kata Pengantar Maksud &amp; Tujuan Jadwal Kegiatan Pemateri &amp; Mediator Para Peserta Manfaat dan Fasilitas Syarat Peserta Masukan &amp; Saran Ucapan Terima Kasih", " WORKSHOP Data Analytics With Python &amp; SQL Bakti Siregar, M.Sc 2023-08-16 Kata Pengantar Di zaman serba digital seperti sekaran ini, data menjadi sumber rujukan utama dalam setiap perencanaan, pengendalian, dan pengembangan diberbagi aspek kehidupan kita. Dampak dari transformasi digital ini adalah semakin bertambahnya kuantitas data yang terus meningkat seperti air mengalir. Sehingga dibutuhkan pengendalian data dengan cepat, tepat dan akurat. Kemampuan dalam menggunakan bahasa pemrograman Python &amp; SQL adalah jawaban bagi setiap individu (professional) yang bekerja dengan data tersebut. Perlu diketahui bahwa Python &amp; SQL sudah terintegrasi dengan sangat baik, mudah dipelajari, fleksibel, dapat digunakan untuk mengakses, memperbarui, memodifikasi, menganalisis data, dan umumnya digunakan dalam basis data relasional yang sangat besar. Maksud &amp; Tujuan Maksud dari kegiatan ini adalah melanjutkan pelatihan data analitik sebelumnya yang berjudul Workshop Data Analytics with Python. Pada workshop kali ini akan digunakan Python dan SQL dengan melibatkan karyawan atau pimpinan instansi masing-masing di JNE. Tujuan yang ingin dicapai dari dilaksanakan pelatihan komputer aplikasi ini adalah : Mengenalkan kepada para karyawan pentingnya penguasaan Python dan SQL dalam mengolah data. Melatih untuk menggunakan Python dan SQL dalam praktek pengolahan data sesuai lingkup pekerjaan. Menerapkan penggunaan Python dan SQL dalam pekerjaan. Jadwal Kegiatan Adapun rencana jadwal kegiatan dan topik pembahasan adalah sebegai berikut Pertemuan 1 Waktu Nama Kegiatan 09:00 ~ 09:15 WIB Pembukaan 09:15 ~ 10:15 WIB Materi I: Pengenalan Python+SQL 10:15 ~ 10:30 WIB Coffee Break I 10:30 ~ 11:30 WIB Materi II: Instalasi Python+SQL 11:30 ~ 13:00 WIB ISOMA 13:00 ~ 14:00 WIB Materi III : Koneksi Python+SQL 14:00 ~ 15:15 WIB Materi IV : Pengantar Python+SQL 15:15 ~ 15:30 WIB ISO 15:30 ~ 16:30 WIB Kuis atau Praktikum oleh Peserta Pertemuan 2 Waktu Nama Kegiatan 09:00 ~ 10:15 WIB Materi I: Pemilahan Data 10:15 ~ 10:30 WIB Coffee Break I 10:30 ~ 11:30 WIB Materi II: Pemilahan Data 11:30 ~ 13:00 WIB ISOMA 13:00 ~ 14:00 WIB Materi III : Meringkas Data 14:00 ~ 15:15 WIB Materi IV : Meringkas Data 15:15 ~ 15:30 WIB ISO 15:30 ~ 16:30 WIB Kuis atau Praktikum oleh Peserta Pertemuan 3 Waktu Nama Kegiatan 09:00 ~ 10:15 WIB Materi I: Mengelompokkan Data 10:15 ~ 10:30 WIB Coffee Break I 10:30 ~ 11:30 WIB Materi II: Mengelompokkan Data 11:30 ~ 13:00 WIB ISOMA 13:00 ~ 14:00 WIB Materi III : Menggabungkan Data 14:00 ~ 15:15 WIB Materi IV : Menggabungkan Data 15:15 ~ 15:30 WIB ISO 15:30 ~ 16:30 WIB Kuis atau Praktikum oleh Peserta Pertemuan 4 Waktu Nama Kegiatan 09:00 ~ 10:15 WIB Materi I: Konversi Waktu 10:15 ~ 10:30 WIB Coffee Break I 10:30 ~ 11:30 WIB Materi II: Menghitung Waktu 11:30 ~ 13:00 WIB ISOMA 13:00 ~ 14:00 WIB Materi III : Subkueri (Subqueries) 14:00 ~ 15:15 WIB Materi IV : Subkueri (Subqueries 15:15 ~ 15:30 WIB ISO 15:30 ~ 16:30 WIB Kuis atau Praktikum oleh Peserta Pertemuan 5 Waktu Nama Kegiatan 09:00 ~ 10:15 WIB Materi I: SQL+Visualisasi 10:15 ~ 10:30 WIB Coffee Break I 10:30 ~ 11:30 WIB SQL+Visualisasi 11:30 ~ 13:00 WIB ISOMA 13:00 ~ 14:00 WIB Studi Kasus: SQL+Visualisasi+Dashboard 14:00 ~ 15:15 WIB Studi Kasus: SQL+Visualisasi+Dashboard 15:15 ~ 15:30 WIB ISO 15:30 ~ 16:30 WIB Kuis atau Praktikum oleh Peserta Pertemuan 6 Waktu Nama Kegiatan 09:00-10:00 WIB Persentasi Kelompok A 10:00 -10:30 WIB Coffee Break I 10:30-11:30 WIB Persentasi Kelompok B 11:30 -13:00 WIB ISOMA 13:00-14:00 WIB Persentasi Kelompok C 15:30-15:30 WIB Pemabahasan Persentasi 15:30-Selesai Penutupan Acara Pelatihan 2 Pemateri &amp; Mediator Berikut ini adalah nama dan biografi singkat para penulis: Bakti Siregar, M.Sc Bakti Siregar seorang lulusan Magister Sains dari departemen matematika terapan di National Sun Yat-Sen University (Taiwan). Beliau adalah seorang Data Scientist profesional yang memiliki Kompetensi tidak dapat diragukan lagi dalam hal pengolahan data dengan menggukan SQL dan bahasa pemrograman Python/Rstudio. Lebih dari pada itu, Dia juga akrab dalam memproses Big Data seperti pengenalan distributed computing, NoSQL Database, Hadoop, Spark dan lainnya. Dalam hal visualisasi data, Bakti Siregar mampu menginterpretasikan data dengan sangat baik menggunakan Tableau maupun Power BI. Beberapa project beliau dapat dilihat di link berikut: Rpubs, Github, Website, dan Kaggle. Yosia adalah salah satu mahasiwa terbaik di jurusan Statistika Universitas Matana. Dia juga memiliki minat dalam pembelajaran sains data dan akuturia khususnya melakukan komputasi dengan menggunakan R dan Python. Yosia bercita-cita suatu saat nanti akan menjadi seseorang yang ahli dibidang aktuaria maupun sain data. Dia memiliki minat teoretis yang luas serta minat dalam komputasi, Yosia pernah terlibat dalam menerbitkan di jurnal Pengabdian Kepada Masyarakat Salah Satunya menjadi Assisten (Workhshop Data Analytics With Python &amp; SQL) yang juga aktif dalam berbagai aktifitas organisasi kampus. Clara Della adalah mahasiswi jurusan Statistik di Universitas Matana. Dia memiliki kemampuan dalam menggunakan beberapa perangkat lunak yang dibutuhkan dalam proses analisa data, seperti; R, Python, SQL, Tableau dan SPSS. Dia juga sudah pernah terlibat menjadi salah satu Assisten (Workhshop Data Analytics With Python &amp; SQL). Selain itu, Della juga aktif dalam berbagai aktifitas organisasi kampus. Para Peserta Adun para peserta pelatihan adalah para karyawan JNE dengan jumlah maksimum peserta 15 orang, sebagai berikut: Manfaat dan Fasilitas Instruktur Berpengalaman di Bidang Analis Data (Akademisi &amp; Praktisi) Pelatihan 6 hari (8 Jam Per-pertemuan) Modul Pelatihan (E-Book yang dapat diakses hanya untuk Peserta dari JNE) Sertifikat Kehadiran (Untuk peserta yang tidak lulus sertifikat kompetensi) Sertifikat Kompetensi dari Dsciencelabs (Analis Data Lanjutan) Laporan Kegiatan Pelatihan Syarat Peserta Laptop yang sudah ter-install Anaconda dan XAMPP atau PostgreSQL Sudah terbiasa dengan data, minimal menggunakan Ms. Excel Berkemauan tinggi untuk belajar Koding Masukan &amp; Saran Akses untuk Ebook ini hanya tersedia secara gratis untuk para peserta Workshop di JNE. Meskipun banyak upaya telah dilakukan untuk pengembangan, tentu kami sangat mengharapkan masukan dari anda sekalian. Ucapan Terima Kasih Kami juga ingin mengucapkan terima kasih yang sebesar-sebesar pada semua pihak yang terlibat dalam pengembangan buku ini, yakni; mahasiswa-i, dosen, dan Universitas Matana atas dukungan dalam upaya bersama kami untuk menyediakan materi untuk **Pelatihan Analisis Data Dengan Menggunakan Python dan SQL” ini. "],["pendahuluan.html", "Bab 1 Pendahuluan 1.1 Apa itu SBD? 1.2 Mengapa Python &amp; SQL? 1.3 MySQL vs PostgreSQL 1.4 Instalasi Python (Anaconda) 1.5 Instalasi MySQL (XAMPP) 1.6 Instalasi PostgreSQL 1.7 Praktikal (Hands On) 1.8 Latihan", " Bab 1 Pendahuluan Sejak tahun 1970, Structured Query Language (SQL) telah digunakan oleh para programmer untuk membangun dan mengakses Sistem Basis Data (SBD). Banyak sekali perdebatan mengenai cara penyebutan SQL ini, namun pada kenyataannya, kita dapat melafalkannya sebagai “sequel” ataupun “S.Q.L”. Mempelajari bahasa pemrograman umum seperti Python dan R adalah penting, namun tidak memiliki kemampuan SQL akan membuat kita amat sulit untuk mendapatkan pekerjaan dalam bidang pengolahan data. Hampir semua nama besar di bidang teknologi menggunakan SQL seperti Uber, Netflix, dan Airbnb. Bahkan dalam perusahaan seperti Facebook, Google dan Amazon, yang telah membuat sendiri SBD berkemampuan tinggi, tetap menggunakan SQL untuk melakukan query dan analisis data. 1.1 Apa itu SBD? Secara umum SBD dapat didefinisikan sebagai berikut: 1.1.1 Komponen SBD Adapun beberapa komponen dasar yang diperlukan dalam SBD adalah: 1.1.2 Manfaat SBD Manfaat atau kegunaan penerapan SBD cukup banyak dan cakupannya pun luas dalam mendukung keberadaan lembaga atau organisasi maupun perusahaan, diantaranya: 1.1.3 Definisi SQL vs NoSQL Sebenarnya perbedaan antara SQL dan NoSQL secara mendasar sudah dapat dijelaskan dari akronimnya. SQL basis data relasional yang menggunakan ‘relasi’ (yang biasanya disebut tabel) untuk menyimpan data dan mencocokkan data tersebut dengan memakai karakteristik umum di setiap dataset. Sedangkan, NoSQL adalah database yang menggunakan format JSON untuk setiap dokumennya sehingga mudah dibaca dan dimengerti. NoSQL banyak diminati karena memiliki performa yang tinggi dan bersifat non-relasional sehingga dapat memakai berbagai model data. 1.1.4 Perbedaan SQL vs NoSQL Sebenarnya banyak perbedaan yang dimiliki di antara dua database tersebut tapi inilah perbedaan yang paling mencolok antara SQL dan NoSQL: 1.1.5 Top 7 SQL Tercatat sampai bulan Februari 2020 ada 334 jenis database menurut db-engines.com. Berikut ini saya merangkum daftar 7 database terpopuler yang menggunakan SQL (Relasional): 1.1.6 Top 8 NoSQL Kebanyakan basis data NoSQL digunakan dalam dunia aplikasi web waktu nyata (real-time web app). Berikut ini adalah ulasan 8 jenis basis data NoSQL yang paling populer digunakan diseluruh dunia: 1.2 Mengapa Python &amp; SQL? Python adalah sebuah bahasa pemrograman yang digunakan untuk membuat aplikasi, perintah komputer, dan melakukan analisis data. SQL adalah sintaks (bahasa) yang digunakan untuk mengatur dan mengambil informasi dari sistem basis data relasional dan yang juga dapat digunakan untuk membuat basis data sendiri. Jadi, kedua perangkat lunak ini mempunyai peran masing-masing. SQL ditujukan untuk mengakses dan mengambil data dari database. Sedangkan Python digunakan untuk menganalisis dan memanipulasi data dengan menggunakan regresi, time series maupun perhitungan lainnya. Jika kita ingin bekerja di bidang pengolahan data, kita harus fokus kepada kemampuan yang diinginkan oleh para perusahaan pemberi kerja tersebut. Untuk posisi analis data, SQL termasuk kemampuan yang diutamakan, sekitar 57.4% dari keseluruhan lowongan pekerjaan. Berdasarkan survei yang dilakukan Dataquest dan StackOverflow pada gambar dibawah ini, dapat dilihat bahwa SQL bahkan lebih populer di kalangan data scientist dan data engineer dibandingkan Python dan R. 1.3 MySQL vs PostgreSQL MySQL adalah sistem manajemen basis data relasional yang memungkinkan Anda untuk menyimpan data sebagai tabel dengan baris dan kolom. Sistem ini populer sehingga digunakan di banyak aplikasi web, situs web dinamis, dan sistem tertanam. PostgreSQL adalah sistem manajemen basis data relasional-objek yang menawarkan lebih banyak fitur daripada MySQL. Sistem ini memberi Anda lebih banyak fleksibilitas dalam tipe data, skalabilitas, konkurensi, dan integritas data. MySQL dan PostgreSQL, Keduanya menyimpan data di dalam tabel yang terkait satu sama lain melalui nilai kolom umum. Namun keduanya sering dibandingkan karena terdapat beberapa perbedaan. Ingin mengenal lebih dalam? Simak penjelasan di bawah. 1.3.1 Kelebihan MySQL PostgreSQL Integrasi bahasa pemrograman sangat luas; Support framework website modern seperti Node.js dan Django; Support framework website modern seperti Node.js dan Django; Aplikasi ringan, tidak membutuhkan spesifikasi hardware yang tinggi; Dirilis dengan lisensi PostgreSQL sendiri; Struktur tabel dengan fleksibilitas tinggi; Bersifat open source dan gratis; Dibekali banyak administrative tools; Skala besar, mampu memuat hingga ribuan transaksi data; Bersifat open source dan gratis (versi basic); Memiliki banyak fitur yang mumpuni; Meski open source, MySQL menjamin keamanan tingkat tinggi; Memiliki banyak fitur yang mumpuni; Mendukung berbagai variasi Data Type; Performa sangat baik meski menuntut query yang lebih kompleks; Dapat digunakan banyak pengguna karena mendukung multi user. Kecepatan analisis (read-write) sangat cepat; Keamanan yang lebih ketat. 1.3.2 Kekurangan MySQL PostgreSQL Sistem manajemen database kurang cocok untuk aplikasi mobile dan game; PostgreSQL tidak mendukung semua stack development; Technical support MySQL dinilai kurang baik; Meski memiliki integrasi dan skalabilitas tinggi, kecepatan PostgreSQL kalah unggul dibandingkan RDBMS lain; Sulit diaplikasikan untuk manajemen database berskala besar. Sistem kompatibilitas PostgreSQL menuntut pengguna untuk bekerja lebih keras dalam perbaikan dan perawatan. 1.4 Instalasi Python (Anaconda) Berikut ini adalah proses langkah demi langkah tentang Cara Menginstal Anaconda di Windows: 1.4.1 Open site Buka Situs Web Anaconda Lalu pilih Download pada logo Windows 1.4.2 Buka file exe yang telah didownload Ketika layar di bawah ini muncul, klik Next. 1.4.3 Baca perjanjian lisensi dan klik I Agree. 1.4.4 Click on Next 1.4.5 Catat lokasi penginstalan Anda, lalu klik Next. 1.4.6 Customiza Anaconda Ini adalah bagian penting dari proses instalasi. approach yang disarankan adalah tidak mencentang kotak untuk menambahkan Anaconda ke path Anda. Ini berarti Anda harus menggunakan Anaconda Navigator atau Anaconda Command Prompt (terletak di Start Menu di bawah “Anaconda”) ketika Anda ingin menggunakan Anaconda (Anda selalu dapat menambahkan Anaconda ke PATH Anda nanti jika Anda tidak mencentang kotak). Jika Anda ingin menggunakan Anaconda pada command prompt Anda (atau git bash, cmder, powershell, dll), gunakan alternative approach dan centang kotaknya. 1.4.7 Setup Complete ###Install Microsoft VSCode Anda dapat menginstal Microsoft VSCode jika Anda mau, tetapi ini opsional. 1.4.8 Selesai Click on Finish. 1.4.9 Video Instalasi Download Anaconda 1.5 Instalasi MySQL (XAMPP) 1.5.1 Download Aplikasi XAMPP Silakan klik disini untuk mengunduh applikasi XAMPP, pilih salah satu saja sesuai Operating System pada Komputer anda. 1.5.2 Install Aplikasi Temukan file XAMPP.exe yang telah anda download, secara default biasanya disimpan di; Selanjutnya, akan muncul Warning di klik OK selajutunya klik next Klik next lagi, karena sudah dipilih secara default oleh XAMPP 1.5.3 Pilih Folder Secara default akan membuat folder baru C:\\xampp, lalu pilih next. note: jika anda sudah pernah mendownload aplikasi xampp, perlu di hapus terlebih dahulu file xampp yang lama di file C:\\xampp 1.5.4 Jalankan proses Instalasi Tunggu proses instalasi selesai Biasanya 5-10 menit, tergantung kecepatan komputer anda. 1.5.5 XAMPP sudah terinstall Setelah aplikasi terinstall, sudah bisa digunakan. 1.5.6 Video Instalasi XAMPP 1.6 Instalasi PostgreSQL Berikut ini adalah proses langkah demi langkah tentang Cara Menginstal PostgreSQL di Windows: 1.6.1 Buka Browser Klik https://www.postgresql.org/download and pilih Windows 1.6.2 Cek Option Klik Download the installer Interactive Installer by EnterpriseDB 1.6.3 Pilih PostgreSQL version Anda akan diminta untuk memilih versi PostgreSQL dan sistem operasi yang diinginkan. Pilih versi PostgreSQL terbaru dan OS sesuai dengan environment Anda, klik tombol download. 1.6.4 Open exe file Setelah Anda mengunduh PostgreSQL, buka exe yang telah diunduh dan Klik berikutnya pada layar install welcome screen. 1.6.5 Pilih folder Ubah direktori Instalasi jika diperlukan, jika tidak, biarkan default, klik Next. 1.6.6 Select components Anda dapat memilih komponen yang ingin Anda instal di sistem Anda. Anda dapat menghapus centang pada Stack Builder (disarankan ikuti secara default), klik Next. 1.6.7 Check data location Anda dapat mengubah lokasi data, Klik Next. 1.6.8 Masukan Password Masukkan kata sandi superuser. Catat kata sandi tersebut, Klik Next. 1.6.9 Cek opsi port Biarkan nomor port menjadi default, Klik Next. 1.6.10 Cek Summary Periksa pra-penginstalan summary, Klik Next 1.6.11 Ready to Install Klik tombol Next 1.6.12 Check stack builder prompt Setelah instalasi selesai, Anda akan melihat prompt Stack Builder. Hapus centang pada opsi tersebut. Kita akan menggunakan Stack Builder dalam tutorial selanjutnya, Klik Finish. 1.6.13 Launch PostgreSQL Untuk launch PostgreSQL, buka Start Menu dan cari pgAdmin 4 1.6.14 Check pgAdmin Anda akan melihat beranda pgAdmin 1.6.15 Cari PostgreSQL 15 Klik pada Servers &gt; PostgreSQL 15 di sub sebelah kiri 1.6.16 Enter password Masukkan kata sandi superuser yang ditetapkan selama instalasi, Klik OK 1.6.17 Cek Dashboard Anda akan melihat Dashboard 1.6.18 Video Instalasi PostgreSQL Download PostgreSQL 1.7 Praktikal (Hands On) Untuk memulai bagian ini, pastikan bahwa anda sudah meng-install Anaconda dan XAMPP dikomputer yang akan digunakan. Kemudian, bukalah applikasi Juperterlab yang ada pada layar Anaconda Navigator, seperti diperlihatkan sebagai berikut: Selanjutnya, akan muncul halaman baru pada browser seperti gambar berikut; Selanjutnya, klik `File &gt; Open from URL’. Muncul tampilan sebagai berukut: Terakhir, Copy-Paste dibawah ini pada kolom Open URL. Selanjutnya, ikuti tutorialnya. Akses Databases MySQL dengan Python Akses Databases PostgreSQL dengan Python Contoh Applikasi Sederhana Py_SQL 1.8 Latihan Berikut ini adalah Soal Latihan yang harus dikerjakan bersama Kelompok masing-masing. Kelompok A Klik disini KOKO ARIF BUDIMAN ALDINO PRASETIAWAN SURISTIN ADNAN HAERUL AGUNG DARMANTO Kelompok B Klik disini M. SYAHRIZAL FAJAR DEMOKRASI PUTRA HARRY KHAIRULLAH IBNU FALAH RESTU KUSUMAWATI Kelompok C Klik disini ADE DARMAWAN RETNO WULANDARI FADILLA ANGGIE PRANANDA WISMOYO BRIHAYADI YUDHA PRATAMA "],["eksplorasi-data.html", "Bab 2 Eksplorasi Data 2.1 Koneksi MySQL dan Python 2.2 CRUDA Tabel 2.3 Filter Tabel 2.4 Tugas Kelompok 2.5 Cara mengatasi XAMPP tidak berfungsi dengan baik", " Bab 2 Eksplorasi Data Pada pertemuan sebelumnya telah depelajari pengenalan dasar bagaimana mengakses basis data dengan menggunakan Python ke MySQL dan PostgreSQL. Pada pertemuan kedua ini, akan fokus untuk berlatih untuk melakukan CRUDA dan Filter tabel. Secara garis besar materi yang akan dibahas adalah; Mengulang kembali bagaimana meng-akses basis data dengan Python ke MySQL dan PostgreSQL Membuat dan menghapus basis data Membuat database lengkap dengan melakukan import data dari Excel (database rekayasa untuk pelatihan Data Analytics di JNE) Operasi tabel pada database Menambahkan pengaturan batasan tabel 2.1 Koneksi MySQL dan Python Untuk mengakses basis data yang ada pada MySQL dengan Python dapat menggunakan koding berikut di Jupiterlab anda. # import module import mysql.connector # koneksi server db1 = mysql.connector.connect( host=&#39;localhost&#39;, user=&#39;bakti&#39;, passwd=&#39;123&#39; ) Jika tidak muncul pesan error pada saat menjalankan koding diatas pada Chunck Jupiterlab anda. Artinya, koneksi Python ke MySQL sudah terhubung dengan baik. 2.1.1 Memeriksa Daftar Database Setelah kita terhubung dengan local server menggunakan Python dan MySQL. Sekarang saatnya kita mulai untuk memerikas database apa saja yang ada didalamnya. # membuat objek &#39;cursor` sebagai kata kunci eksekusi SQL cursor1 = db1.cursor() # Perintah SQL sql = &#39;SHOW DATABASES&#39; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar database for x in cursor1: print(x) 2.1.2 Membuat Database Berikut ini adalah koding yang dapat digunakan untuk membuat database baru dengan menggunakan koneksi db.cursor() yang ada pada objek cursor. sql= &#39;CREATE DATABASE jne2&#39; cursor1.execute(sql) 2.1.3 Menghapus Database Jika anda ingin menghapus database tertentu dari lokal server, maka dapat melakukannya dengan koding berikut: sql= &#39;DROP DATABASE jne2&#39; cursor1.execute(sql) 2.1.4 Memeriksa Daftar Tabel Untuk memeriksa daftar tabel yang ada pada local server. Perhatikan Koding berikut: # import module import mysql.connector # koneksi salah satu database MySQl ke Python db2 = mysql.connector.connect( host=&#39;localhost&#39;, user=&#39;bakti&#39;, passwd=&#39;123&#39;, database=&#39;jne2&#39; ) # membuat objek &#39;cursor` sebagai kata kunci eksekusi SQL cursor2 = db2.cursor() # Perintah SQL sql = &quot;SHOW TABLES&quot; # Eksekusi perintah SQL cursor2.execute(sql) # menampilkan daftar tabel for x in cursor2: print(x) 2.2 CRUDA Tabel Pada materi sebelumnya telah dipelajari bagaimana untuk melakukan CRUDA Tabel yang ada pada database. CRUDA merupakan singkatan dari **Create, Read, Update, Delete, dan Alter. Berikut ini akan diperlihatkan cara untuk menambahkan daftar database dari CSV. Langkah pertama, import data dari Excel menggukan Python. import pandas as pd link_data = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/inventory_items.csv&#39; df1 = pd.read_csv(link_data, sep=&#39;;&#39; ) df1.head(5) 2.2.1 CREATE Jika data tabel yang telah di import dari file CSV sudah ada dalam memori Jupeterlab (Python) anda, maka selanjutnya untuk menambahkan tabel tersebut ke database adalah sebagai berikut: import pymysql from sqlalchemy import create_engine # membuat engine engine = create_engine(&quot;mysql+pymysql://{user}:{pw}@localhost/{db}&quot; .format(user=&quot;bakti&quot;, pw=&quot;123&quot;, db=&quot;jne2&quot;)) # df1.to_sql(&#39;users&#39;, engine, if_exists = &#39;append&#39;, index = True) df1.to_sql(&#39;user&#39;, engine, if_exists=&#39;replace&#39;, index = False) Tugas Kelompok: Tambahkan tabel berikut ke database jne2 dengan mengikuti materi yang sudah anda pelajari sebelumnya. https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/products.csv https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/orders.csv https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/order_items.csv https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/inventory_items.csv https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/events.csv https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/distribution_centers.csv 2.2.2 READ Berbeda dengan materi materi dasar yang kita pelajari sebelumnya, untuk membaca data tabel dari database dalam bentuk dataframe dapat dilakukan dengan cara berikut; import pandas as pd en_co = engine.connect() read1 = pd.read_sql_table(&#39;distribution_centers&#39;, en_co) read1 2.2.3 UPDATE Sama seperti yang telah dipelajari sebelumnya, melakukan update data pada tabel disini dapat dilakukan dengan cara berikut: import pandas as pd en_co = engine.connect() sql = &#39;UPDATE distribution_centers SET name=%s, latitude=%s, longitude=%s WHERE id=%s&#39; val = (&quot;JNE&quot;, 106.7977, -6.1774, 10) cursor2.execute(sql, val) db2.commit() pd.read_sql_table(&#39;distribution_centers&#39;, en_co) Tugas Kelompok: Tambahkan satu lokasi baru pada tabel distribution_centers Tambahkan tiga lokasi baru pada tabel distribution_centers 2.2.4 DELETE Pada bagian hapus data sama seperti update data. Kita harus menggunakan query DELETE untuk menghapus dan WHERE untuk menentukan data yang akan dihapus. sql = &quot;DELETE FROM distribution_centers WHERE id=%s&quot; val = (11, ) cursor2.execute(sql, val) db2.commit() print(&quot;{} data dihapus&quot;.format(cursor2.rowcount)) Tugas Kelompok: Hapuskan tiga lokasi baru sebelumnya, yang anda tambahkan pada tabel distribution_centers secara bersamaan. Catatan: Untuk menghapus kolom dalam tabel, gunakan sintaks berikut (perhatikan bahwa beberapa sistem database tidak mengizinkan penghapusan kolom): sql = &quot;ALTER TABLE distribution_centers \\ DROP COLUMN email&quot; cursor2.execute(sql) db2.commit() 2.2.5 ALTER Ada kalanya kita ingin menambah, memodifikasi, menghapus yang ada pada tabel. Pernyataan yang digunakan adalah ALTER TABLE, seperti diperlihatkan sebagai berikut: sql = &#39;ALTER TABLE distribution_centers \\ ADD email VARCHAR(100) \\ FIRST&#39; cursor2.execute(sql) db2.commit() 2.3 Filter Tabel Berikut ini adalah beberapa cara yang dapat digunakan untuk memilah-milah tabel dari database. 2.3.1 SELECT pilih_tab = pd.read_sql(&#39;SELECT * FROM distribution_centers&#39;, db2) pilih_tab Untuk memilih beberapa kolom saja dari tabel adalah sebagai berikut: pilih_kol = pd.read_sql(&#39;SELECT id, name FROM distribution_centers&#39;, db2) pilih_kol 2.3.2 WHERE Kondisi yang dinyatakan pada klausa WHERE bisa simpel ataupun kompleks. Kita dapat menggabungkan beberapa kondisi menggunakan logical connectives (AND, OR dan NOT) menjadi sebuah kondisi tunggal. Berikut adalah contoh penggunaan klausa WHERE: sql = &#39;SELECT * FROM distribution_centers WHERE id&lt;=3&#39; kondisi = pd.read_sql(sql, db2) kondisi sql = &#39;SELECT * FROM distribution_centers WHERE id=3 AND name= &quot;Houston TX&quot;&#39; kondisi = pd.read_sql(sql, db2) kondisi 2.3.3 ORDER BY Klausa ORDER BY digunakan untuk menampilkan output dalam bentuk urutan alfabet ASCending atau DESCending. sql = &#39;SELECT * FROM distribution_centers ORDER BY name ASC;&#39; or_by = pd.read_sql(sql, db2) or_by 2.3.4 LIMIT Klausa LIMIT digunakan untuk membatasi hasil query kita sesuai dengan angka yang kita tetapkan. sql = &#39;SELECT * FROM distribution_centers LIMIT 3;&#39; or_by = pd.read_sql(sql, db2) or_by Coba perhatikan koding berikut: sql = &#39;SELECT * FROM distribution_centers LIMIT 3,5&#39; or_by = pd.read_sql(sql, db2) or_by 2.4 Tugas Kelompok Diskusikan dan Kerjakan soal berikut bersama Kelompok Masing2. Tambahkanlah kolom Product_Price pada table inventory_items Hapuslah kolom Product_Price pada table inventory_items Tambahkanlah kolom Id pada table orders Hapuslah kolom Id pada table orders Tambahkanlah kolom Total_Sales pada table order_items Hapuslah kolom Total_Sales pada table order_items Tampilkanlah data yang order_id&gt;= 50 dari table orders Tampilkanlah data berdasarkan negara london dari table events Tampilkanlah data yang memiliki product_id = 9482 dari table inventory_items Tampilkanlah data yang memiliki id = 72884 dan dengan status cancelled dari table order_items Urutkanlah Data dari table distribution_centers dengan nama dari huruf z ke a Urutkanlah Data dari table order_items dengan sale_price dari terkecil ke besar Tambahkan Tabel dari local (tidak menggunakan link) ke database jne2 Upload Tugas 2 Kelompok A Disini Upload Tugas 2 Kelompok B Disini Upload Tugas 2 Kelompok C Disini 2.5 Cara mengatasi XAMPP tidak berfungsi dengan baik https://www.amalankomputer.com/2021/01/cara-mengatasi-apache-shutdown.html "],["perhitungan-statistik-dasar.html", "Bab 3 Perhitungan &amp; Statistik Dasar 3.1 Fungsi Skalar vs Agregat 3.2 Perhitungan GROUP BY 3.3 Perhitungan HAVING 3.4 Perhitungan CASE WHEN 3.5 Tugas Kelompok (Selesai duluan C, A, B)", " Bab 3 Perhitungan &amp; Statistik Dasar Pada dasarnya SQL bukan saja hanya dapat dipergunakan untuk melakukan manajemen database. Tetapi, dapat juga melakukan perhitungan matematika dan statistika dasar yang pada akhirnya dapat disimpan pada database untuk keperluan analisa. Secara spesifik, pelatihan ini akan membahas beberapa diantaranya yakni mengenai penggunaan fungsi sklar dan fungsi agregat. 3.1 Fungsi Skalar vs Agregat Fungsi skalar atau fungsi math dalam SQL digunakan untuk mengembalikan nilai tunggal (single value) dari suatu nilai input yang diberikan pada perintah sebelumnya. Sedangkan, Fungsi agregat dalam SQL digunakan untuk melakukan perhitungan matematika pada sekelompok nilai dan kemudian mengembalikan nilai tunggal. 3.1.1 Perhitungan Skalar Sebelum kita memulai melakukan beberapa perhitungan skalar pada data yang kita pilih dari database. Pertama-tama, mari kita lihat dulu isi data pada tabel berikut: from sqlalchemy import create_engine import pymysql import pandas as pd # membuat engine engine = create_engine(&quot;mysql+pymysql://{user}:{pw}@localhost/{db}&quot; .format(user=&quot;bakti&quot;, pw=&quot;123&quot;, db=&quot;jne2&quot;)) # engine koneksi ke database db_enco = engine.connect() # Perintah SQL sql = &quot;SELECT * FROM inventory_items&quot; # Eksekusi perintah SQL dengan Python (panda) pd.read_sql(sql,db_enco) Berikut ini adalah beberapa contoh dan deskripsi Fungsi Skalar yang terdapat dalam SQL: Fungsi ABS() Fungsi ABS() adalah sebagai untuk menampilkan nilai absolut dari suatu bilangan bulat. Sebelum memulai menggunakan fungsi ABS(), perlu untuk membuat objek koneksi dan kursor eksekusinya terlebih dahulu. # import module import mysql.connector # koneksi salah satu database MySQl ke Python db1 = mysql.connector.connect( host=&#39;localhost&#39;, user=&#39;bakti&#39;, passwd=&#39;123&#39;, database=&#39;jne2&#39; ) # membuat objek &#39;cursor` sebagai kata kunci eksekusi SQL cursor1 = db1.cursor() Selanjutnya, berikut ini diperlihatkan contoh penerapan fungsi ABS(). # Perintah SQL sql = &quot;SELECT ABS(cost) \\ FROM inventory_items \\ WHERE product_id=16898&quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) Dari hasil diatas diperlihatkan beberapa hasil yang sama. Untuk menangani hal tersebut, perhatikan koding berikut: # Perintah SQL sql = &quot;SELECT DISTINCT ABS(cost) \\ FROM inventory_items \\ WHERE product_id=16898&quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) 3.1.2 Perhitungan Agregat Berikut ini adalah beberapa contoh dan deskripsi Fungsi Agregat yang terdapat dalam SQL: Fungsi COUNT(*) Fungsi COUNT(*) mengembalikan jumlah baris yang dikembalikan oleh pernyataan SELECT, termasuk NULL dan duplikat, sedangkan COUNT(column) mengembalikan jumlah baris yang dikembalikan oleh klausa SELECT. # Perintah SQL sql = &quot;SELECT COUNT(product_category) \\ FROM inventory_items \\ WHERE cost&lt;5&quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) Tugas Mandiri Apakah hasil Kueri diatas duah benar? Perhatikan Strukrur tabel Cost! Cobalah untuk melakukan penjumlahan total pada product_category, dimana Cost&lt;5. Paparkan temuan anda! Fungsi COUNTD(*) Fungsi COUNTD() adalah fungsi yang digunakan untuk menghitung jumlah baris secara bersusun dengan hanya berfungsi pada karakter yang berbeda. Misal jika terdapat tabel dengan baris 1,2,3,4,4,5,6,6,7 bersusun, maka yang terhitung jumlah barisnya hanya ada 7, karena hanya ada 7 buah karakter yang unik. Syntax fungsi COUNTD() secara umum adalah sebagai berikut : Tugas Mandiri: Pada jenis data apakah kita dapat menggunaka fungsi SUM()? Jika dalam fungsi SUM() menggunakan opsi DISTINCT, apakah yang tejadi? 3.2 Perhitungan GROUP BY Jika ingin memunculkan rata-rata dari cost untuk setiap product_department? # Perintah SQL sql = &quot;SELECT product_department, \\ AVG(cost) \\ FROM inventory_items \\ GROUP BY product_category;&quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) Notes: Perhatikan hasilnya Group By dapat digunakan untuk mengelompokkan data berdasarkan nilai dari barisnya. Lebih dari sekedar mengelompokkan data, Group By biasanya juga disandingkan dengan Fungsi Aggregate. Fungsi-fungsi Aggregate ini merupakan fungsi yang sudah dipelajari sebelumnya, seperti: SUM(), AVG(), COUNT() dan lain sebagainya. Tugas Kelompok Tampilkan jumlah brand yang ada pada pada tabel products dan urutkan dari besar ke kecil! 3.3 Perhitungan HAVING Jika WHERE digunakan di conditional statement yang diaplikasikan pada kolom, maka HAVING digunakan untuk conditional statement di level group. HAVING dapat digunakan untuk memutuskan grup mana yang akan dipilih atau difilter pada hasil akhir. HAVING dapat digunakan dengan clause SUM(), AVG(), COUNT() dan fungsi agregat yang lain, tetapi tidak untuk WHERE. # Perintah SQL sql = &quot;SELECT brand, COUNT(brand) AS Jumlah_brand\\ FROM products \\ GROUP BY brand \\ HAVING (brand) = 2 &quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) 3.4 Perhitungan CASE WHEN CASE digunakan layaknya seperti IF-ELSE pada beberapa bahasa pemrograman yang lain. Berikut ini adalah gambaran bagaimana CASE bekerja 3.4.1 Buat Struktur Tabel # Perintah SQL sql = &quot;CREATE TABLE jadwal \\ (kegiatan varchar(20), \\ senin varchar(10), \\ selasa varchar(10), \\ rabu varchar(10), \\ kamis varchar(10), \\ jumat varchar(10), \\ sabtu varchar(10)) &quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) 3.4.2 Insert Data # Perintah SQL sql = &quot;INSERT INTO jadwal values \\ (&#39;olahraga&#39;,&#39;ya&#39;,&#39;tidak&#39;,&#39;ya&#39;,&#39;tidak&#39;,&#39;ya&#39;,&#39;tidak&#39;), \\ (&#39;diskusi&#39;,&#39;tidak&#39;,&#39;ya&#39;,&#39;tidak&#39;,&#39;tidak&#39;,&#39;tidak&#39;,&#39;ya&#39;), \\ (&#39;rapat&#39;,&#39;ya&#39;,&#39;tidak&#39;,&#39;tidak&#39;,&#39;tidak&#39;,&#39;tidak&#39;,&#39;tidak&#39;), \\ (&#39;ulangan&#39;,&#39;tidak&#39;,&#39;ya&#39;,&#39;ya&#39;,&#39;ya&#39;,&#39;tidak&#39;,&#39;tidak&#39;)&quot; # Eksekusi perintah SQL cursor1.execute(sql) db1.commit() # menampilkan daftar tabel for data in cursor1: print(data) 3.4.3 Lihat Data Tabel # Perintah SQL sql = &quot;SELECT * FROM jadwal;&quot; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar tabel for data in cursor1: print(data) 3.4.4 Perhitungan CASE sql = &quot;SELECT jadwal.*, \\ CASE WHEN senin=&#39;ya&#39; THEN 1 ELSE 0 END \\ + CASE WHEN selasa=&#39;ya&#39; THEN 1 ELSE 0 END \\ + CASE WHEN rabu=&#39;ya&#39; THEN 1 ELSE 0 END \\ + CASE WHEN kamis=&#39;ya&#39; THEN 1 ELSE 0 END \\ + CASE WHEN jumat=&#39;ya&#39; THEN 1 ELSE 0 END \\ + CASE WHEN sabtu=&#39;ya&#39; THEN 1 ELSE 0 END AS digunakan, \\ CASE WHEN senin=&#39;tidak&#39; THEN 1 ELSE 0 END \\ + CASE WHEN selasa=&#39;tidak&#39; THEN 1 ELSE 0 END \\ + CASE WHEN rabu=&#39;tidak&#39; THEN 1 ELSE 0 END \\ + CASE WHEN kamis=&#39;tidak&#39; THEN 1 ELSE 0 END \\ + CASE WHEN jumat=&#39;tidak&#39; THEN 1 ELSE 0 END \\ + CASE WHEN sabtu=&#39;tidak&#39; THEN 1 ELSE 0 END AS tidak_digunakan \\ FROM jadwal;&quot; # Eksekusi perintah SQL cursor1.execute(sql) # Menampilkan daftar tabel for data in cursor1: print(data) 3.5 Tugas Kelompok (Selesai duluan C, A, B) Gunakan tabel order_items untuk mengetahui total dari beberapa status pengiriman Pada tabel inventory_items. Tampilkan informasi kategori, nama produk dan biaya (dengan kondisi pembulatan dua angka dibelakang koma) tanpa duplikat dengan memfilter berdasarkan kategori produk (bebas pilih) Pada tabel products, urutkan dari yang terbesar rata-rata harga retail berdasarkan jenis brand Kelompokkan inventory_items berdasarkan kategori produk lalu, filter Total Biaya lebih dari 150 Kelompokkan inventory_items berdasarkan nama dan department produk dengan kasus total biaya untuk department laki-laki kurang dari 200 dan department perempuan lebih dari 200. Lalu urutkan dari yang terbesar "],["join-tabel-subkueri.html", "Bab 4 Join Tabel &amp; Subkueri 4.1 Pendahuluan 4.2 CREATE Database Baru 4.3 Join Tabel 4.4 SUBQUERY 4.5 Studi Kasus 4.6 Soal Latihan Kelompok", " Bab 4 Join Tabel &amp; Subkueri 4.1 Pendahuluan Pada bagian pendahuluan ini kita akan membahas query untuk menampilkan data dari beberapa tabel MySQL. Karena sering kali mengambil data dari database yang disimpan di beberapa tabel untuk diolah sehingga menjadi satu keluaran. Kita menggunakan empat tabel, yaitu: tabel pelanggan, produk, transaksi, dan transaksi_detail. Struktur dan hubungan keempat tabel tersebut tampak seperti pada gambar berikut: 4.2 CREATE Database Baru Pertama-tama kita buat database baru untuk menyimpan menyimpan tabel seperti dipelihatkan diatas, sebagai berikut: # import module import mysql.connector # koneksi server db1 = mysql.connector.connect( host=&#39;localhost&#39;, user=&#39;bakti&#39;, passwd=&#39;123&#39; ) # membuat objek &#39;cursor` sebagai kata kunci eksekusi SQL cursor1 = db1.cursor() # Perintah SQL sql=&#39;&#39;&#39;CREATE DATABASE IF NOT EXISTS join_tabel&#39;&#39;&#39; # Eksekusi perintah SQL cursor1.execute(sql) Untuk memastikan koneksi sudah berhasil, berikut ini coba check database yang sudah tersimpan di server lokal anda. # Perintah SQL sql = &#39;SHOW DATABASES&#39; # Eksekusi perintah SQL cursor1.execute(sql) # menampilkan daftar database for x in cursor1: print(x) 4.2.1 CREATE Tabel Sintaks berikut ini adalah untuk membangun ke-empat tabel yang kan kita gunakan. Pertama-tama kita buatkan koneksi dan kursor baru sebagai berikut: # import module import mysql.connector # koneksi server db2 = mysql.connector.connect( host=&#39;localhost&#39;, user=&#39;bakti&#39;, passwd=&#39;123&#39;, database=&#39;join_tabel&#39; ) # membuat objek &#39;cursor` sebagai kata kunci eksekusi SQL cursor2 = db2.cursor() Setelah koneksi dan kursor baru berhasil dibuatkan, berikutnya kita buatkan struktur tabel yang diperlukan; Struktur Tabel Barang # Perintah SQL sql = &#39;&#39;&#39; CREATE TABLE IF NOT EXISTS `barang` ( `id_barang` int(11) NOT NULL AUTO_INCREMENT, `id_kategori` smallint(6) NOT NULL, `nama_barang` varchar(255) CHARACTER SET latin1 NOT NULL, `harga` int(11) NOT NULL, `stok` int(11) NOT NULL, PRIMARY KEY (`id_barang`) ); &#39;&#39;&#39; # Eksekusi perintah SQL cursor2.execute(sql) # Simpan perubahan db2.commit() Struktur Tabel Pelanggan # Perintah SQL sql = &#39;&#39;&#39; CREATE TABLE IF NOT EXISTS `pelanggan` ( `id_pelanggan` int(11) NOT NULL AUTO_INCREMENT, `nama` varchar(50) DEFAULT NULL, `email` varchar(50) DEFAULT NULL, PRIMARY KEY (`id_pelanggan`) ); &#39;&#39;&#39; # Eksekusi perintah SQL cursor2.execute(sql) # Simpan perubahan db2.commit() Struktur Tabel Penjualan # Perintah SQL sql = &#39;&#39;&#39; CREATE TABLE IF NOT EXISTS `penjualan` ( `id_transaksi` int(11) NOT NULL AUTO_INCREMENT, `id_pelanggan` int(11) DEFAULT NULL, `tgl_transaksi` date NOT NULL, `total_transaksi` int(11) NOT NULL, PRIMARY KEY (`id_transaksi`), KEY `FK_penjualan_pelanggan` (`id_pelanggan`), CONSTRAINT `FK_penjualan_pelanggan` FOREIGN KEY (`id_pelanggan`) REFERENCES `pelanggan` (`id_pelanggan`) ON DELETE SET NULL ON UPDATE CASCADE ); &#39;&#39;&#39; # Eksekusi perintah SQL cursor2.execute(sql) # Simpan perubahan db2.commit() Struktur Tabel Detail Penjualan # Perintah SQL sql = &#39;&#39;&#39; CREATE TABLE IF NOT EXISTS `penjualan_detail` ( `id_transaksi_detail` int(11) NOT NULL AUTO_INCREMENT, `id_transaksi` int(11) DEFAULT NULL, `id_barang` int(11) DEFAULT NULL, `jml_barang` smallint(6) DEFAULT NULL, `harga_satuan` int(11) DEFAULT NULL, PRIMARY KEY (`id_transaksi_detail`), KEY `FK_tb_penjualan_detail_tb_barang` (`id_barang`), KEY `FK_tb_penjualan_detail_tb_penjualan` (`id_transaksi`), CONSTRAINT `FK_tb_penjualan_detail_tb_barang` FOREIGN KEY (`id_barang`) REFERENCES `barang` (`id_barang`) ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT `FK_tb_penjualan_detail_tb_penjualan` FOREIGN KEY (`id_transaksi`) REFERENCES `penjualan` (`id_transaksi`) ON DELETE CASCADE ON UPDATE CASCADE ) &#39;&#39;&#39; # Eksekusi perintah SQL cursor2.execute(sql) # Simpan perubahan db2.commit() Catatan: Pengertian Cascade dalam MySql Keterangan: Pengaturan Struktur Tabel SQL digunakan untuk menentukan aturan struktur data dalam tabel. Batasan digunakan untuk membatasi jenis data yang dapat masuk ke dalam tabel, memastikan keakuratan dan keandalan data dalam tabel. Batasan dapat berupa tingkat kolom atau tingkat tabel. Batasan tingkat kolom berlaku untuk kolom, dan batasan tingkat tabel berlaku untuk keseluruhan tabel. Berikut Batasan yang biasanya digunakan dalam SQL: NOT NULL: Memastikan kolom tidak boleh memiliki nilai NULL UNIQUE: Memastikan bahwa semua nilai dalam kolom berbeda PRIMARY KEY: Kombinasi NOT NULL dan UNIQUE. Secara unik mengidentifikasi setiap baris dalam tabel FOREIGN KEY: Secara unik mengidentifikasi baris/record di tabel lain CHECK: Memastikan bahwa semua nilai dalam kolom memenuhi kondisi tertentu DEFAULT: Menetapkan nilai default untuk kolom saat tidak ada nilai yang ditentukan INDEX: Digunakan untuk membuat dan mengambil data dari database dengan sangat cepat AUTO_INCREMENT: memungkinkan inset data unik pada kolom tertentu yang dihasilkan secara otomatis saat data baru dimasukkan ke dalam tabel. Seringkali kolom ini adalah adalah juga PRIMARY KEY dan ingin dibuat secara otomatis setiap kali catatan baru dimasukkan. 4.2.2 INSERT Data Tabel Berikut ini adalah koding yang digunakan untuk menambahkan data ke dalam tabel; Insert Data Barang sql = &#39;&#39;&#39; INSERT INTO `barang` (`id_barang`, `id_kategori`, `nama_barang`, `harga`, `stok`) VALUES (%s, %s, %s, %s, %s)&#39;&#39;&#39; values = [(1, 1, &#39;RAM&#39;, 230000, 4), (2, 1, &#39;Mainboard&#39;, 1250000, 7), (3, 1, &#39;Mouse&#39;, 80000, 6), (4, 3, &#39;Mousepad&#39;, 35000, 3), (5, 3, &#39;Keyboard&#39;, 80000, 5) ] for val in values: cursor2.execute(sql, val) db2.commit() Insert Data Pelanggan sql = &#39;&#39;&#39; INSERT INTO `pelanggan` (`id_pelanggan`, `nama`, `email`) VALUES (%s, %s, %s)&#39;&#39;&#39; values = [(1, &#39;Alfa&#39;, &#39;alfa@yahoo.com&#39;), (2, &#39;Beta&#39;, &#39;beta@gmail.com&#39;), (3, &#39;Delta&#39;, &#39;delta@hotmail.com&#39;), (4, &#39;Bakti&#39;, &#39;dsciencelabs@outlook.com&#39;) ] for val in values: cursor2.execute(sql, val) db2.commit() Insert Data Penjualan sql = &#39;&#39;&#39; INSERT INTO `penjualan` (`id_transaksi`, `id_pelanggan`, `tgl_transaksi`, `total_transaksi`) VALUES (%s, %s, %s, %s)&#39;&#39;&#39; values = [(1, 1, &#39;2023-06-22&#39;, 230000), (2, 3, &#39;2023-06-22&#39;, 195000), (3, 2, &#39;2023-05-01&#39;, 1710000), (4, 1, &#39;2023-07-04&#39;, 310000), (5, 3, &#39;2023-07-10&#39;, 80000) ] for val in values: cursor2.execute(sql, val) db2.commit() Insert Data Penjulan Detail sql = &#39;&#39;&#39; INSERT INTO `penjualan_detail` (`id_transaksi_detail`, `id_transaksi`, `id_barang`, `jml_barang`, `harga_satuan`) VALUES (%s, %s, %s, %s, %s); &#39;&#39;&#39; values = [(1, 1, 1, 1, 230000), (2, 2, 4, 1, 35000), (3, 2, 5, 2, 80000), (4, 3, 2, 1, 1250000), (5, 3, 1, 2, 230000), (6, 4, 4, 2, 35000), (7, 4, 5, 1, 80000), (8, 4, 3, 2, 80000), (9, 5, 3, 1, 80000) ] for val in values: cursor2.execute(sql, val) db2.commit() 4.2.3 READ Tabel Membaca data tabel SQL dengan Python diperlukan koneksi dan engine yang aktif untuk memuat data yang diperlihatkan ke pengguna. Berikut ini adalah langkah pembentukan koneksi dan enginya. from sqlalchemy import create_engine import pymysql import pandas as pd # membuat engine engine = create_engine(&quot;mysql+pymysql://{user}:{pw}@localhost/{db}&quot; .format(user=&quot;bakti&quot;, pw=&quot;123&quot;, db=&quot;join_tabel&quot;)) # engine koneksi ke database en_co = engine.connect() Read Tabel Barang Selanjutnya, untuk membaca tabel sql menjadi DataFrame, tanpa mengeksekusi kueri apa pun, kita dapat menggunakan fungsi read_sql_table() yang ada pada library Pandas. barang = pd.read_sql(&#39;barang&#39;, en_co) barang Read Tabel Pelanggan pelanggan = pd.read_sql(&#39;pelanggan&#39;, en_co) pelanggan Read Tabel Penjualan penjualan = pd.read_sql(&#39;penjualan&#39;, en_co) penjualan Read Tabel Penjulan Detail detail_penjualan = pd.read_sql(&#39;penjualan_detail&#39;, en_co) detail_penjualan 4.3 Join Tabel SQL JOIN adalah fungsi yang disediakan SQL yang digunakan untuk menggabungkan tabel melalui kolom atau key tertentu yang nilainya saling terkait untuk memperoleh sekumpulan data dengan informasi yang lengkap. Dengan perintah JOIN pengguna dapat menggabungkan beberapa tabel agar mendapat informasi secara lengkap sesuai yang dibutuhkan untuk analisis. Beberapa jenis join tabel ini akan dijelaskan satu persatu pada sub-topik berikut. 4.3.1 INNER JOIN Pada MySQL, penulisan INNER JOIN dapat dilakukan dengan tiga cara yaitu (1) menggunakan klausa INNER JOIN (2) menggunakan klausa CROSS JOIN (3) cukup menggunakan klausa JOIN saja. Pengguna bebas menggunakan sintaks yang mana saja asal konsisten, penulis lebih prefer menggunakan JOIN saja, karena lebih simpel. Sebagai contoh kita akan menampilkan data pelanggan yang melakukan pesanan, query yang kita jalankan: # Perintah SQL sql = &#39;&#39;&#39; SELECT pl.id_pelanggan, nama, tgl_transaksi, total_transaksi FROM pelanggan AS pl JOIN penjualan AS pn ON pl.id_pelanggan = pn.id_pelanggan &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) Tabel yang dihasilkan adalah tabel yang berisikan nilai yang sama pada kedua tabel (matching values). Jika menggunakan klausa USING, maka query akan berbentuk seperti berikut: # Perintah SQL sql = &#39;&#39;&#39; SELECT pl.id_pelanggan, nama, tgl_transaksi, total_transaksi FROM pelanggan AS pl JOIN penjualan AS pn USING(id_pelanggan) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) Kuis: Berdasarkan hasil diatas, pada saat kapan sebiaknya anda akan menggunakan join tabel? 4.3.2 LEFT JOIN Pada LEFT JOIN, semua data pada tabel sebelah kiri akan ditampilkan, sedangkan data pada tabel disebelah kanan hanya akan ditampilkan jika data terkait pada tabel tersebut muncul di tabel sebelah kiri. Contohnya, kita tampilkan semua data pelanggan beserta data transaksinya, jalankan query berikut: # Perintah SQL sql = &#39;&#39;&#39; SELECT * FROM pelanggan AS pl LEFT JOIN penjualan AS pn USING(id_pelanggan) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) 4.3.3 LEFT JOIN (Partial) Tabel yang dihasilkan akan mengandung seluruh nilai tabel di sisi kiri, dengan nilai yang sama antara tabel kiri dan kanan. # Perintah SQL sql = &#39;&#39;&#39; SELECT * FROM pelanggan AS pl LEFT JOIN penjualan AS pn USING(id_pelanggan) WHERE pn.id_pelanggan IS NULL &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) Kuis: Berdasarkan hasil diatas, pada saat kapan sebiaknya anda akan menggunakan Left Join (Partial)? 4.3.4 RIGHT JOIN Kebalikan dari LEFT JOIN, pada RIGHT JOIN, data pada tabel sebelah kanan akan ditampilkan semua, sedangkan data pada sebelah kiri hanya ditampilkan jika data terkait pada tabel tersebut muncul pada tabel sebelah kanan. # Perintah SQL sql = &#39;&#39;&#39; SELECT * FROM pelanggan pl RIGHT JOIN penjualan USING(id_pelanggan) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) Kuis: Perlukah RIGHT JOIN? Jika kita teliti lebih lanjut, sebenarnya right join hanya memindah posisi tabel, dari kiri ke kanan, contoh query pada right join dapat kita ubah dengan menjadi LEFT JOIN dengan mengubah posisi tabel. 4.3.5 FULL JOIN Tabel yang dihasilkan adalah tabel dengan semua nilai dari kedua tabel. Apabila terdapat nilai yang tidak memiliki kesamaan dari kedua tabel, maka muncul nilai null. # Perintah SQL sql = &#39;&#39;&#39; SELECT * FROM penjualan AS pn JOIN penjualan_detail AS pede ON pn.id_transaksi != pede.id_transaksi &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) 4.3.6 Implisit Join Tabel Sejauh ini, kita menampilkan data dari beberapa tabel MySQL dengan menggunakan klausa JOIN. Selain menggunakan klausa JOIN, terdapat satu cara lagi untuk menggabungkan tabel MySQL, yaitu menggunakan implisit join, disebut implisit join karena kita tidak menggunakan klausa JOIN, pada implisit join, kriteria hubungan antar tabel di definisikan pada klausa WHERE. Sebagai contoh, mari kita gabungkan tabel pelanggan dan penjualan, jalankan query berikut: # Perintah SQL sql = &#39;&#39;&#39; SELECT pl.id_pelanggan, nama, id_transaksi, tgl_transaksi, total_transaksi FROM pelanggan pl, penjualan pn WHERE pl.id_pelanggan = pn.id_pelanggan &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) Perhatikan bahwa hasil tersebut sama persis dengan hasil pada contoh INNER JOIN, sehingga dapat disimpulkan bahwa implisit join = inner join. Implisit JOIN ini merupakan cara lama ketika pertama kali standar SQL dibuat, setelah muncul standar yang lebih baru (SQL2) maka mulai digunakanlah klausa JOIN. Saya sendiri prefer menggunakan klausa JOIN karena lebih mudah dibaca dan dipahami, terutama hubungan antara tabel yang digabungkan. Pada bentuk klausa JOIN, hubungan antar tabel dinyatakan pada klausa ON atau USING, sedangkan filter datanya dilakukan pada klausa WHERE, misal: # Perintah SQL sql = &#39;&#39;&#39; SELECT pl.id_pelanggan, nama, id_transaksi, tgl_transaksi, total_transaksi FROM pelanggan pl LEFT JOIN penjualan pn USING (id_pelanggan) WHERE pl.id_pelanggan = 2 OR pl.id_pelanggan = 1 &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) Sedangkan pada implisit JOIN, hubungan antar tabel dan filter datanya, semua didefinisikan pada klausa WHERE, misal: # Perintah SQL sql = &#39;&#39;&#39; SELECT pl.id_pelanggan, nama, id_transaksi, tgl_transaksi, total_transaksi FROM pelanggan pl, penjualan pn WHERE pl.id_pelanggan = pn.id_pelanggan AND (pl.id_pelanggan = 2 OR pl.id_pelanggan = 1) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co) 4.4 SUBQUERY Subquery yang digunakan adalah scalar subquery, tetapi subqueries juga dibagi menjadi beberapa tipe berdasarkan penggunaannya yaitu sebagaimana dikutip dari Scalar: Single row subquery Multiple row subquery Correlated subquery Nested subqueries 4.4.1 Single row subquery hasil yang diperoleh digunakan sebagai operator pembanding seperti =, &gt;, &lt;, atau klausa IN. from sqlalchemy import create_engine import pymysql import pandas as pd # membuat engine engine = create_engine(&quot;mysql+pymysql://{user}:{pw}@localhost/{db}&quot; .format(user=&quot;bakti&quot;, pw=&quot;123&quot;, db=&quot;jne2&quot;)) # engine koneksi ke database en_co2 = engine.connect() Contoh dibawah ini adalah melihat status dari harga jual maksimum dari order items. # Perintah SQL sql = &#39;&#39;&#39; SELECT order_id, product_id, status , sale_price FROM `order_items` WHERE sale_price = (SELECT MAX(sale_price) FROM `order_items`) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) 4.4.2 Multiple row subquery Multiple row subquery merupakan jenis subquery yang menghasilkan beberapa baris data. Serupa dengan single row subquery, hasil yang diperoleh dari subquery akan digunakan sebagai operator pembanding. Contoh dibawah ini adalah melihat negara-negara mana saja yang berada berdasarkan tabel products. Maka akan ditampilkan bahwa didalam tabel products, hanya distribusi dari 6 negara. # Perintah SQL sql = &#39;&#39;&#39; SELECT id, name,latitude, longitude FROM `distribution_centers` WHERE id IN (SELECT distribution_center_id FROM `products`) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) 4.4.3 Correlated Subquery Correlated subquery merupakan jenis subquery yang hasilnya bergantung dengan query utama (main query). Sifatnya yang dependen membuat subquery jenis ini berbeda dari jenis lainnya. Ciri-ciri subquery jenis ini adalah memiliki sumber data yang sama dengan query utama. Umumnya, hasil yang diperoleh akan digunakan untuk memfilter hasil dari query utama. Contohnya adalah dengan mengambil id, product_id, product_category, dan product_name dengan melihat product retail price yang lebih kecil dari rata rata product retail price keseluruhannya. # Perintah SQL sql = &#39;&#39;&#39; SELECT id,product_id, product_category, product_name FROM `inventory_items` WHERE product_retail_price &lt;(SELECT AVG(product_retail_price) FROM `inventory_items`) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) 4.4.4 Nested Subqueries Nested Subqueries merupakan jenis subqueries di mana terdapat subquery lain di dalam subquery. Pada umumnya, subquery jenis ini digunakan untuk perhitungan atau filter yang cukup kompleks untuk sebuah dataset. Contoh disini tidak jauh beda dengan contoh sebelumnya namun disini dikhususkan untuk product category “ACCESSORIES” # Perintah SQL sql = &#39;&#39;&#39; SELECT id,product_id,product_name FROM `inventory_items` WHERE product_retail_price &lt; (SELECT AVG(product_retail_price) FROM `inventory_items` WHERE product_category=&quot;Accessories&quot;) &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) 4.5 Studi Kasus Database JNE2 adalah data fiktif yang dikembangkan oleh tim dsciencelabs untuk pelatihan Data Analytics with Python &amp; SQL. Kumpulan data tersebut berisi informasi tentang pelanggan, produk, pesanan, logistik, promosi, dan kampanye pemasaran digital. Tugas peserta pelatihan di sini adalah menjawab beberapa pertanyaan terkait bisnis, mendapatkan wawasan, dan memberikan beberapa rekomendasi untuk meningkatkan pendapatan suatu perusahaan. 4.5.1 Soal 1 Andaikan Divisi Marketing akan memberikan promosi selama perayaan Imlek untuk pelanggan wanita di Jepang melalui email. Bagaimana anda mendapatkan data tentang berapa banyak pelanggan yang harus dipromosikan setiap email! # Perintah SQL sql = &#39;&#39;&#39; SELECT id, email FROM `users` WHERE gender = &#39;F&#39; AND country = &#39;Japan&#39; ORDER BY 1 &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) Kuis: Apakah maksud dari ORDER BY 1 ? 4.5.2 Soal 2 Cara pemasaran apa yang harus perlu ditingkatkan oleh marketing? # Perintah SQL sql = &#39;&#39;&#39; SELECT u.traffic_source, COUNT(DISTINCT oi.user_id) total_customer FROM `order_items` oi LEFT JOIN `users` u ON oi.user_id = u.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 2 DESC &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) 4.5.3 Soal 3 Berikan daftar 10 id pelanggan dengan total pembelian paling banyak secara keseluruhan. # Perintah SQL sql = &#39;&#39;&#39; SELECT oi.user_id, u.email, SUM(oi.sale_price*o.num_of_item) total_purchase FROM `order_items` oi LEFT JOIN `users` u ON oi.user_id = u.id LEFT JOIN `orders` o ON oi.order_id = o.order_id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1, 2 ORDER BY 3 DESC LIMIT 10 &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, en_co2) 4.6 Soal Latihan Kelompok Berapa Penjualan setiap barang yang terdapat pada penjualan detail Siapa Nama Pelanggan yang total transaksi paling banyak Nama Barang yang dibeli oleh setiap pelanggan dan jumlahnya Mencari dan Menunjukkan Status dari orders dengan berdasarkan nilai maximum dari order_id dengan menampilkan order_id, user_id, num_of_item, status. Mencari dan Menunjukkan Negara mana saja yang TIDAK tercantum dalam data inventory_items dengan menampilkan id, name,latitude, longitude. Mencari dan Menunjukkan nama product dan brand jika dengan berdasarkan retail price lebih besar dari rata-rata retail price keseluhurannya dalam data products dengan menampilkan id,name,brand Mencari dan Menunjukkan nama product jika dengan berdasarkan retail price lebih besar dari rata-rata retail price keseluhurannya dalam data products Serta berdasarkan brand “TYR” dengan menampilkan id,cost,name,sku "],["visualisasi-dashboard.html", "Bab 5 Visualisasi &amp; Dashboard 5.1 Buat Database Baru 5.2 Import Tabel ke Database 5.3 Latihan 5.4 Tugas", " Bab 5 Visualisasi &amp; Dashboard Pertemuan kali ini kita akan fokus pada pelatihan visualisasi yang sudah perlah dipelajari pada wokshop sebelumnya yaitu Data Analytics with Python. Kita akan mulai dengan mengakses database terlebih dahulu, kemudian melakukan kueri sesuai kebutuhan analisis, selanjutnya menampilkannya dalam bentuk visual, dan pada akhirnya membentuk dashboard. 5.1 Buat Database Baru Pertama-tama buatlah koneksi Python ke database MySQL menggunakan dan mengatifkan XAMPP. # import module import mysql.connector # koneksi server db1 = mysql.connector.connect( host=&#39;localhost&#39;, user=&#39;bakti&#39;, passwd=&#39;123&#39; ) # membuat objek &#39;cursor` sebagai kata kunci eksekusi SQL cursor1 = db1.cursor() # Perintah SQL sql=&#39;&#39;&#39;CREATE DATABASE IF NOT EXISTS dashboard&#39;&#39;&#39; # Eksekusi perintah SQL cursor1.execute(sql) 5.2 Import Tabel ke Database Berikut ini adalah cara untuk menambahkan tabel ke database dengan menggunakan file csv yang telah desediakan. 5.2.1 Impot Data CSV import pandas as pd # read data CSV link1 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/users.csv&#39; link2 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/products.csv&#39; link3 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/orders.csv&#39; link4 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/order_items.csv&#39; link5 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/inventory_items.csv&#39; link6 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/events.csv&#39; link7 = &#39;https://raw.githubusercontent.com/dsciencelabs/JNE_Data_Analytics_PySQL/main/data/data_latihan/distribution_centers.csv&#39; df1 = pd.read_csv(link1, sep=&#39;;&#39; ) df2 = pd.read_csv(link2, sep=&#39;;&#39; ) df3 = pd.read_csv(link3, sep=&#39;;&#39; ) df4 = pd.read_csv(link4, sep=&#39;;&#39; ) df5 = pd.read_csv(link5, sep=&#39;;&#39; ) df6 = pd.read_csv(link6, sep=&#39;;&#39; ) df7 = pd.read_csv(link7, sep=&#39;;&#39; ) 5.2.2 Konversi Tanggal &amp; Waktu Merubah struktur tanggal dan waktu menggunakan Pandas. df1[&#39;created_at&#39;] = df1[&#39;created_at&#39;].apply(pd.to_datetime) df3[df3.columns[4:8]] = df3[df3.columns[4:8]].apply(pd.to_datetime) df4[df4.columns[6:10]] = df4[df4.columns[6:10]].apply(pd.to_datetime) df5[df5.columns[2:4]] = df5[df5.columns[2:4]].apply(pd.to_datetime) df6[&#39;created_at&#39;] = df6[&#39;created_at&#39;].apply(pd.to_datetime) 5.2.3 Simpan Tabel ke Database Berikut ini adalah langkah untun menyimpan tabel ke database. import pymysql from sqlalchemy import create_engine # membuat engine engine = create_engine(&quot;mysql+pymysql://{user}:{pw}@localhost/{db}&quot; .format(user=&quot;bakti&quot;, pw=&quot;123&quot;, db=&quot;dashboard&quot;)) # df1.to_sql(&#39;users&#39;, engine, if_exists = &#39;append&#39;, index = True) df1.to_sql(&#39;users&#39;, engine, if_exists=&#39;replace&#39;, index = False) df2.to_sql(&#39;products&#39;, engine, if_exists=&#39;replace&#39;, index = False) df3.to_sql(&#39;orders&#39;, engine, if_exists=&#39;replace&#39;, index = False) df4.to_sql(&#39;order_items&#39;, engine, if_exists=&#39;replace&#39;, index = False) df5.to_sql(&#39;inventory_items&#39;, engine, if_exists=&#39;replace&#39;, index = False) df6.to_sql(&#39;events&#39;, engine, if_exists=&#39;replace&#39;, index = False) df7.to_sql(&#39;distribution_centers&#39;, engine, if_exists=&#39;replace&#39;, index = False) 5.3 Latihan 5.3.1 Soal 1 Proporsi pelanggan berdasarkan jenis kelamin. # Perintah SQL sql = &#39;&#39;&#39; SELECT o.gender, SUM(oi.sale_price*o.num_of_item) revenue, SUM(o.num_of_item) quantity FROM `order_items` oi LEFT JOIN `orders` o ON oi.order_id = o.order_id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 2 &#39;&#39;&#39; # Eksekusi perintah SQL df1=pd.read_sql(sql, engine) df1 Visualisasi dengan Pie-Chart import plotly.express as px fig = px.pie(df1, values=&#39;revenue&#39;, names=&#39;gender&#39;, hole=.3, title=&#39;Revenue Pelanggan Berdasarkan Gender&#39;) fig.show() 5.3.2 Soal 2 Proporsi pelanggan berdasarkan kategori usianya? # Perintah SQL sql = &#39;&#39;&#39; SELECT CASE WHEN u.age &lt;15 THEN &#39;Kids&#39; WHEN u.age BETWEEN 15 AND 24 THEN &#39;Teenager&#39; WHEN u.age BETWEEN 25 AND 50 THEN &#39;Adult&#39; WHEN u.age &gt;50 THEN &#39;Eldery&#39; END AS age_group, COUNT(DISTINCT oi.user_id) total_customer FROM `order_items` oi LEFT JOIN `users` u ON oi.user_id = u.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 2 DESC &#39;&#39;&#39; # Eksekusi perintah SQL df2=pd.read_sql(sql, engine) df2 Visualisasi dengan Bar-Chart fig = px.bar(df2, x=&#39;age_group&#39;, y=&#39;total_customer&#39;, color=&#39;age_group&#39;) fig.show() 5.3.3 Soal 3 Urutkan jumlah pelanggan terbanyak berdasarkan Negara, dan Jenis Kelaminnya. # Perintah SQL sql = &#39;&#39;&#39; WITH cust AS ( SELECT DISTINCT oi.user_id, SUM(CASE WHEN u.gender = &#39;M&#39; THEN 1 ELSE null END) AS male, SUM(CASE WHEN u.gender = &#39;F&#39; THEN 1 ELSE null END) AS female, u.country AS country FROM `order_items` AS oi INNER JOIN `users` AS u ON oi.user_id = u.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1, 4 ) SELECT c.country, COUNT(DISTINCT c.user_id) AS customers_count, COUNT(c.female) AS female, COUNT(c.male) AS male FROM cust AS c GROUP BY 1 ORDER BY 2 DESC &#39;&#39;&#39; # Eksekusi perintah SQL df3=pd.read_sql(sql, engine) df3 import plotly.express as px fig = px.bar(df3, x=&quot;country&quot;, y=[&quot;customers_count&quot;,&quot;female&quot;, &quot;male&quot;], text_auto=True) fig.show() 5.3.4 Soal 4 Top 10 Brand apa paling banyak revenue dan juga paling banyak terjual? # Perintah SQL sql = &#39;&#39;&#39; SELECT p.brand, SUM(oi.sale_price*o.num_of_item) AS revenue, SUM(o.num_of_item) AS quantity FROM `order_items` AS oi LEFT JOIN `orders` AS o ON oi.order_id = o.order_id LEFT JOIN `products` AS p ON oi.product_id = p.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 3 DESC LIMIT 10 &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, engine) 5.3.5 Soal 5 Media pemasaran terbaik yang sebaiknya digunakan Marketing? # Perintah SQL sql = &#39;&#39;&#39; SELECT u.traffic_source, COUNT(DISTINCT oi.user_id) total_customer FROM `order_items` oi LEFT JOIN `users` u ON oi.user_id = u.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 2 DESC &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, engine) 5.3.6 Soal 6 Berikan alamat email dan user_id dari 10 pelanggan dengan total pembelian terbanyak. # Perintah SQL sql = &#39;&#39;&#39; SELECT oi.user_id, u.email, SUM(oi.sale_price*o.num_of_item) total_purchase FROM `order_items` oi LEFT JOIN `users` u ON oi.user_id = u.id LEFT JOIN `orders` o ON oi.order_id = o.order_id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1, 2 ORDER BY 3 DESC LIMIT 10 &#39;&#39;&#39; # Eksekusi perintah SQL pd.read_sql(sql, engine) 5.4 Tugas Top 10 Merek produk yang paling banyak dibatalkan dan dikembalikan. Top 10 kategori produk yang paling banyak dibatalkan dan dikembalikan. "],["persentasi-tugas-akhir.html", "Bab 6 Persentasi Tugas Akhir 6.1 Studi Kasus jne_db 6.2 Create Database 6.3 Import Data CSV 6.4 Konversi Struktur Tabel 6.5 Simpan Tabel ke Database 6.6 Contoh Soal 1 6.7 Contoh Soal 2 6.8 Contoh Soal 3 6.9 Contoh Soal 4 6.10 Contoh Soal 5 6.11 Contoh Soal 6 6.12 Contoh Soal 7 6.13 Contoh Soal 8 6.14 Ujian", " Bab 6 Persentasi Tugas Akhir Pada pertemuan ini akan dilakukan evaluasi dan peninjauan ulang materi yang sudah dipelajara selama pelatihan Data Analytics with Python &amp; SQL. Pertama-tama akan direview materi sebelumnya dengan simulasi studi kasus. 6.1 Studi Kasus jne_db Database jne_db adalah database fiktif yang dikembangkan oleh dscienclabs. Kumpulan data tersebut berisi informasi tentang pelanggan, produk, pesanan, logistik, kegiatan, dan kampanye pemasaran digital. Database ini digunakan dalam pelatihan kepada praktisi data di industri yang bertujuan untuk pemahaman analisis data, penemuan ide, pengembangan pengetahuan. Berikut ini adalah struktur database yang digunakan: 6.2 Create Database Pada bagian ini diperlihatkan koding Python dan sintaks PostgreSQL untuk membentuk database baru yang diberi nama jne_db. # load modul yg diperlukan import psycopg2 # buat koneksi python ke PostgreSQL (127.0.0.1 atau localhost) konek = psycopg2.connect(user=&#39;postgres&#39;, password=&#39;123&#39;, host=&#39;localhost&#39;, port= &#39;5432&#39; ) konek.autocommit = True # Eembuat kursor eksekutor kursor = konek.cursor() # Kueri sql = &#39;&#39;&#39;CREATE DATABASE JNE_db&#39;&#39;&#39;; #Creating a database kursor.execute(sql) 6.3 Import Data CSV Karena kita ingin membambahkan kumpulan data tabel ke database jne_db dari file CSV maka terlebih dahulu, dilakukan import data sebagai berikut: import os os.chdir(&#39;C:/Users/user/Desktop/jne_db&#39;) 6.4 Konversi Struktur Tabel Pada bagian ini, kita melakukan penyimpanan tabel yang telah diimport dari file CSV ke database PostgreSQL. # import pandas lib as pd import pandas as pd # read by default 1st sheet of an excel file df1 = pd.read_csv(&#39;distribution_centers.csv&#39;,sep=&#39;;&#39;) df2 = pd.read_csv(&#39;events.csv&#39;,sep=&#39;,&#39;) df2[&#39;created_at&#39;] = df2[&#39;created_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df2[&#39;created_at&#39;] = pd.to_datetime(df2[&#39;created_at&#39;]) df3 = pd.read_csv(&#39;inventory_items.csv&#39;,sep=&#39;,&#39;) cols = df3.columns[2:4] df3[&#39;created_at&#39;] = df3[&#39;created_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df3[&#39;sold_at&#39;] = df3[&#39;sold_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df3[cols] = df3[cols].apply(pd.to_datetime) df4 = pd.read_csv(&#39;order_items.csv&#39;,sep=&#39;,&#39;) df4[&#39;created_at&#39;] = df4[&#39;created_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df4[&#39;shipped_at&#39;] = df4[&#39;shipped_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df4[&#39;delivered_at&#39;] = df4[&#39;delivered_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df4[&#39;returned_at&#39;] = df4[&#39;returned_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) cols = df4.columns[6:10] df4[cols] = df4[cols].apply(pd.to_datetime) df5 = pd.read_csv(&#39;orders.csv&#39;,sep=&#39;,&#39;) df5[&#39;created_at&#39;] = df5[&#39;created_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df5[&#39;shipped_at&#39;] = df5[&#39;shipped_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df5[&#39;delivered_at&#39;] = df5[&#39;delivered_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df5[&#39;returned_at&#39;] = df5[&#39;returned_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) cols = df5.columns[4:8] df5[cols] = df5[cols].apply(pd.to_datetime) df6 = pd.read_csv(&#39;products.csv&#39;,sep=&#39;,&#39;) df7 = pd.read_csv(&#39;users.csv&#39;,sep=&#39;,&#39;) df7[&#39;created_at&#39;] = df7[&#39;created_at&#39;].str.replace(&#39;UTC&#39;, &#39;&#39;) df7[&#39;created_at&#39;] = pd.to_datetime(df7[&#39;created_at&#39;]) 6.5 Simpan Tabel ke Database Pada bagian ini, kita melakukan penyimpanan tabel yang telah diimport dari file CSV ke database PostgreSQL. import pandas as pd from sqlalchemy import create_engine import psycopg2 from sqlalchemy import text engine = create_engine(&#39;postgresql://postgres:123@localhost:5432/jne_db&#39;) df1.to_sql(&quot;distribution_centers&quot;, engine) df2.to_sql(&quot;events&quot;, engine) df3.to_sql(&quot;inventory_items&quot;, engine) df4.to_sql(&quot;order_items&quot;, engine) df5.to_sql(&quot;orders&quot;, engine) df6.to_sql(&quot;products&quot;, engine) df7.to_sql(&quot;users&quot;, engine) Catatan: Sebaiknya lakukan Import Data, Konversi, dan Penyimpanan database menggunakan Jupterlab. 6.6 Contoh Soal 1 Visualisasikan total order berdasarkan status! query = &#39;&#39;&#39;SELECT date_trunc(&#39;MONTH&#39;, created_at) AS Month_Year, status, COUNT(DISTINCT user_id) as total_unique_users, COUNT(DISTINCT order_id) as total_orders, SUM(sale_price) as total_sale_price FROM order_items WHERE DATE(created_at) BETWEEN &#39;2020-01-01&#39; AND &#39;2023-07-31&#39; GROUP BY 1,2 ORDER BY 1,2 &#39;&#39;&#39; df = pd.read_sql(query, engine) df crosstb=pd.crosstab(df[&#39;month_year&#39;], df[&#39;status&#39;], df[&#39;total_orders&#39;], aggfunc=&#39;sum&#39;) crosstb.head(5) import matplotlib.pyplot as plt import plotly.express as px fig1 = px.histogram(df, x=&quot;month_year&quot;, color=&quot;status&quot;, y=&#39;total_orders&#39;, title=&quot;Total Order Berdasarkan Status&quot;, barmode=&#39;group&#39;, height=500 ) fig1.show() Jika ditampilkan dengan Line-Chart, sebagai berikut: import matplotlib.pyplot as plt import plotly.express as px fig2 = px.line(df, x=&quot;month_year&quot;, color=&quot;status&quot;, y=&#39;total_orders&#39;, title=&quot;Total Order Berdasarkan Status&quot;, height=200 ) fig2.show() 6.7 Contoh Soal 2 Hitung dan Visualiasikan AOV order_item yang closed setiap bulannya! Catatan: Average Order Value (AOV) adalah sebuah indikator yang menghitung besar pengeluaran pelanggan setiap kali mereka memesan atau membeli barang. Jadi, secara matematis, rumusnya adalah: \\[AOV = \\text{Total penghasilan dalam periode A} / \\text{Total transaksi dalam periode A}\\] Periode A yang dimaksud di sini dapat berupa 1 tahun, 3 bulan, 2 minggu, atau bahkan sehari. Misalkan, AOV brand tersebut adalah Rp30.000, yang berarti secara rata-rata pembeli mengeluarkan Rp30.000 setiap transaksi. with engine.begin() as conn: query = text(&#39;&#39;&#39;SELECT date_trunc(&#39;month&#39;, created_at) AS Month_Year, ROUND((COUNT(DISTINCT order_id)/COUNT(DISTINCT user_id)),2) AS frequencies, ((SUM(sale_price)/COUNT(DISTINCT order_id))) AS AOV, COUNT(DISTINCT user_id) AS total_unique_users FROM order_items WHERE status = &#39;Complete&#39; AND DATE(created_at) BETWEEN &#39;2019-01-01&#39; AND &#39;2022-08-31&#39; GROUP BY 1 ORDER BY 1&#39;&#39;&#39;) df = pd.read_sql_query(query, conn) df 6.8 Contoh Soal 3 Carilah Produk yang paling Menguntungkan! with engine.begin() as conn: query = text(&#39;&#39;&#39;WITH main AS (SELECT name AS product_name, products.id AS products_id, ROUND(retail_price) AS retail_price, ROUND(cost) AS cost, SUM(sale_price-cost) AS profit FROM products JOIN order_items ON products.id = order_items.product_id WHERE status = &#39;Complete&#39; GROUP BY 1,2,3,4), top_least AS (SELECT *, RANK() OVER (ORDER BY profit ASC) AS top_rank FROM main), top_most AS(SELECT *, RANK() OVER (ORDER BY profit DESC) AS top_rank FROM main) SELECT * , &#39;least profit&#39; AS rank_values FROM top_least UNION ALL SELECT *, &#39;most profit&#39; AS rank_values FROM top_most ORDER BY top_rank, rank_values DESC LIMIT 10&#39;&#39;&#39;) df = pd.read_sql_query(query, conn) df 6.9 Contoh Soal 4 Dalam laporan ini kamu akan melihat beberapa detail penjualan seperti: Total Transactions: Total nominal transaksi seluruh outlet(Dalam Rupiah) Total Transaction Count: Total jumlah transaksi si seluruh outlet. Total Outlet: Total jumlah outlet yang bertransaksi di akun tersebut. with engine.begin() as conn: query = text(&quot;&quot;&quot;WITH total_profit AS (SELECT DATE(orders.shipped_at) AS order_date, products.category AS product_categories, SUM(sale_price-cost) AS profit FROM products INNER JOIN order_items orders ON products.id = orders.product_id WHERE status = &#39;Complete&#39; AND orders.created_at BETWEEN &#39;2022-06-01&#39;AND &#39;2022-08-15&#39; GROUP BY 1,2 ORDER BY 2,1 ), MTD_table AS (SELECT order_date, product_categories, profit, SUM(profit) OVER(PARTITION BY product_categories, EXTRACT(MONTH FROM order_date) ORDER BY 2,1) AS MTD FROM total_profit ORDER BY 2,1 ) SELECT order_date, product_categories, round(MTD) AS MTD FROM MTD_table WHERE order_date BETWEEN &#39;2022-06-01&#39;AND &#39;2022-08-15&#39; AND EXTRACT(DAY FROM order_date) = 15&quot;&quot;&quot;) df = pd.read_sql_query(query, conn) df Nb: Total Penjualan Month to Date (MTD) 6.10 Contoh Soal 5 Persentasi perbandingan total inventori sebelum dan seudah with engine.begin() as conn: query = text(&quot;&quot;&quot;WITH inventory AS ( SELECT date_trunc(&#39;month&#39;, created_at) AS Month_Year , product_category AS categories , COUNT(id) AS total_inventory FROM inventory_items WHERE created_at BETWEEN &#39;2019-12-01&#39; AND &#39;2022-04-30&#39; GROUP BY 1,2 ) , previous_inventory as ( SELECT * , LAG (total_inventory) over (partition by inventory.categories order by date_trunc(&#39;month&#39;, Month_year)DESC,inventory.categories) AS total_prev_inv FROM inventory ) SELECT *, ROUND((total_inventory-total_prev_inv)/total_prev_inv*100) AS Growth FROM previous_inventory ORDER BY 1,2&quot;&quot;&quot;) df = pd.read_sql_query(query, conn) df 6.11 Contoh Soal 6 Menghitung jumlah revenue dan order item! with engine.begin() as conn: query = text(&quot;&quot;&quot;SELECT DATE_TRUNC(&#39;month&#39;,oi.created_at) AS order_date, SUM(oi.sale_price*o.num_of_item) AS revenue, COUNT(DISTINCT oi.order_id) AS order_count, COUNT(DISTINCT oi.user_id) AS customers_purchased FROM order_items AS oi LEFT JOIN orders AS o ON oi.order_id = o.order_id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 1 DESC&quot;&quot;&quot;) df = pd.read_sql_query(query, conn) df 6.12 Contoh Soal 7 Jumlah Pelanggan berdasarkan Negara, Pisahkan Berdasarkan Gender! with engine.begin() as conn: query = text(&quot;&quot;&quot;WITH cust AS ( SELECT DISTINCT oi.user_id, SUM(CASE WHEN u.gender = &#39;M&#39; THEN 1 ELSE null END) AS male, SUM(CASE WHEN u.gender = &#39;F&#39; THEN 1 ELSE null END) AS female, u.country AS country FROM order_items AS oi INNER JOIN users AS u ON oi.user_id = u.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1, 4 ) SELECT c.country, COUNT(DISTINCT c.user_id) AS customers_count, COUNT(c.female) AS female, COUNT(c.male) AS male FROM cust AS c GROUP BY 1 ORDER BY 2 DESC&quot;&quot;&quot;) df = pd.read_sql_query(query, conn) df 6.13 Contoh Soal 8 Buatlah Visualisasi Jumlah Pelanggan berdasarkan Kategori with engine.begin() as conn: query = text(&quot;&quot;&quot;SELECT CASE WHEN u.age &lt;15 THEN &#39;Kids&#39; WHEN u.age BETWEEN 15 AND 24 THEN &#39;Teenager&#39; WHEN u.age BETWEEN 25 AND 50 THEN &#39;Adult&#39; WHEN u.age &gt;50 THEN &#39;Eldery&#39; END AS age_group, COUNT(DISTINCT oi.user_id) total_customer FROM order_items oi LEFT JOIN users u ON oi.user_id = u.id WHERE oi.status NOT IN (&#39;Cancelled&#39;,&#39;Returned&#39;) GROUP BY 1 ORDER BY 2 DESC&quot;&quot;&quot;) df = pd.read_sql_query(query, conn) df 6.14 Ujian 6.14.1 Onsite Hitunglah persentasi Status Pemesanan Produk menggunakan (Pie-chart)! Total jumlah barang Terjual dengan Status Complete Setiap Tahunnya (Pie-chart)! Total jumlah barang Terjual berdasarkan Kategori Produk (Bar-chart)! Total Revenue Barang Terjual berdasarkan Kategori Produk (Bar-chart)! Total Sale Price, Cost, dan Laba Kotor bulanan Multi Line-Chart! 6.14.2 Take Home Buatlah Visualisasi Data Customer PEREMPUAN berdasarkan Negara dengan memperhatikan status “RETURNED” saja. Visualisasi total orders complete pada tahun 2022 Bandingkan total order yang Complete dan Returned perbulan dalam satu grafik garis? Produk category apa yang memiliki penjualan tertinggi (revenue) pada setiap tahun (dibandingakan)? (2020-2023) dan Buatkan Visualisasi datanya! note: status nya harus Complete,Shipped,Processing. Jangan masukan status yang Cancelled dan Returned Hint : sale_price pada order_items dikali dengan num_of_time pada orders untuk menentukan revenue jadi ada 3 tabel yang digunakan yaitu products, orders,order_items Visualisasi Data Customers dengan berdasarkan Country menggunakan Pie Chart Melihat Penjualan Tahunan berdasarkan status yang ’COMPLETE” berdasarkan profit dan reveneunya dengan menerapkannya pada visualisasi data. "],["penutup.html", "Bab 7 Penutup", " Bab 7 Penutup "],["section.html", "", " "],["daftar-pustaka.html", "Daftar Pustaka", " Daftar Pustaka "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
